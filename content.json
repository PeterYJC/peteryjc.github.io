{"pages":[],"posts":[{"title":"Java中static, final, static final的区别","text":"通常情况下， 类成员需要通过它的类的对象访问，如果一个成员被声明为static，它能够在它的类的任何对象创建之前被访问， 而不用引用任何对象。 声明为static的一个类变量或方法，所有的该类的实例都会共享这个static变量或方法。 staticstatic修饰变量 静态变量在内存中只有一份， jvm只为静态变量分配一次内存，随着类的加载而加载到静态方法区内存中。由于静态变量属于类，和类的实例无关， 所以可以直接通过类名进行访问。 对于成员变量，每创建一个该类的实例就会创建该成员变量的一个拷贝，分配一次内存，由于成员变量是和类的实例绑定的，所以不能直接通过类名对它进行访问。 static修饰方法 只能调用其他的static方法 只能访问static数据 不能以任何方式引用this 和super 静态方法可以直接通过类名调用， 任何该类的实例也可以调用它的静态方法， 所以静态方法不能用this或者super。 static 方法独立于任何实例， 所以static方法必须被实现，不能是抽象的absract，在static方法里引用任何的实例变量都是违法的。 static 修饰类普通类不允许被声明为静态， 只有内部类才可以。被static修饰的内部类可以作为一个普通类来使用， 而不需实例一个外部类（不需要new，直接静态加载）。 内部类没有使用static关键字，不能直接创建实例。 不使用static修饰内部类 12345678910111213public class OuterClass { public class InnerClass{ InnerClass(){} }}public class TestStaticClass { public static void main(String[] args) { // OutClass需要先生成一个实例 OuterClass oc = new OuterClass(); oc.new InnerClass(); }} 使用static修饰内部类 123456789101112public class OuterClass { public static class InnerClass{ InnerClass(){} }}public class TestStaticClass { public static void main(String[] args) { // OutClass 不需要生成实例 new OuterClass.InnerClass(); }} static修饰代码块123static { System.out.println(\"test\");} 它独立于类成员，可以有多个， jvm 加载类的时候会执行这些静态代码块， 如果有static代码块多个，jvm会按照他们在类中出现的顺序执行且每个只执行一次。可以通过静态代码块对static变量进行赋值。 finalfinal可以修饰非抽象类， 非抽象类成员方法和变量 final修饰变量一个变量可以声明为final， 目的是阻止它的内容被修改， 这意味着声明final变量的时候， 必须对其进行初始化，这种用法有点类似于c++的const。 通常，我们会用 final定义一些常量 ， 如 123final float PI=3.14final boolean SUCCESS = true..... 按照编码约定， final变量的所有字符选择大写，final修饰的变量实际中不占用内存， 它实质上是一个常数。 final修饰方法被final修饰的方法可以被子类继承， 但不能被子类的方法覆盖。 如果一个类不想让其子类覆盖它的某个成员方法， 就可以用 final关键字修饰该方法。 final不能修饰构造方法。 由于父类中private 成员方法不能被子类覆盖， 所有由private修饰的方法默认也是final的。 使用final修饰成员方法除了不想让子类覆盖外， 还有一个原因就是高效，Java编译器在遇到final修饰的方法的时候会转入内嵌机制， 提高执行效率。 内嵌机制 ，类似于c++ inline, 调用方法的时候直接将方法的主题插入到调用处， 而不用去访问类或者对象， 这样会提高50%左右效率。然而，如果方法主体比较庞大， 且多处被调用将导致主体代码膨胀， 同时也产生效率问题， 所以需要慎用。 final修饰类final修饰的类不能被继承。 final和static同时使用同时使用 final和static修饰类成员， 该类成员拥有二者特性。 1static final int LIMIT=100; // LIMIT表示全局常量 如果是方法的话，方法可以被继承， 可以通过类名被访问， 但是不能被子类覆盖。 对于一些用final和static修饰的容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。","link":"/2019/11/04/final-static-finalwithstatic/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/04/hello-world/"},{"title":"用户态和内核态的区别","text":"由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级—用户态和内核态。 什么是用户态和内核态内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。 用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。 用户态与内核态的切换所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作。 内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系,intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。 这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令。 这种机制叫系统调用, 在CPU中的实现称之为陷阱指令(Trap Instruction)当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。用户态和内核态的转换 用户态切换到内核态的3种方式系统调用这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 异常当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 外围设备的中断当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。 具体的切换操作从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括： 123451. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务。2. 用户态程序执行陷阱指令。3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务。5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果。 至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。","link":"/2019/11/15/yonghutai-neihetai/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"java关键字","slug":"java关键字","link":"/tags/java关键字/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"内核态","slug":"内核态","link":"/tags/内核态/"},{"name":"用户态","slug":"用户态","link":"/tags/用户态/"}],"categories":[{"name":"java基础","slug":"java基础","link":"/categories/java基础/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"Linux基础","slug":"Linux基础","link":"/categories/Linux基础/"}]}